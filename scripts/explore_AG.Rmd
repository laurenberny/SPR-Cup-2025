---
title: "Exploratorium"
author: "Anwesha Guha"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
pacman::p_load(here, rio, tidyverse)
```

```{r}
load(here("data", "combined_clean.RData"))
```

## Weight exploration

The weighted tutorial notes to calibrate weights to standardize mean? I am just curious about what these weights look like, so let's see weight 2. Strange that there are so many NAs.
```{r}
summary(full$rep_weight_2) #1,199
length(unique(full$id)) #63,181 weights -- #43,932 IDs
```

Note for weights (from video):
- `survey` package in R can handle weights
- use BRR variance estimation (another option is linearization/Taylor Series)
- cross-sectional weights are specific to wave; single-wave is slightly different. We have the cross-sectional weights since we are looking at overall characteristics of the Wave 4 vs Wave 7 samples. If we were interested in individual-level tracking, we'd use the all-waves weights, but that's not relevant to our RQs.

## Omitting weights

### Data exploration

Create variable factors and strata.
```{r}
full %>% 
 dplyr::select(-contains("weight")) %>% 
 mutate(across(2:7, as.factor)) %>% 
 mutate(race_ethnicity = as.factor(paste0(race, ", ", ethnicity)),
        strata_label = paste(region, race_ethnicity, sexuality, sex, age, sep = "_")) %>% 
 head()
```

Descriptive summary by strata
```{r}
full %>% 
  dplyr::select(-contains("weight")) %>% 
 mutate(across(2:7, as.factor)) %>% 
 mutate(race_ethnicity = as.factor(paste0(race, ", ", ethnicity)),
        strata_label = paste(region, race_ethnicity, sexuality, sex, age, sep = "_")) %>% 
 group_by(strata_label) %>% 
 summarise(tot = sum(eprod_edsd)) %>% 
 arrange(tot)
```

Remove NA values? What is the best method we want to use?

I'm doing listwise just to continue on with the exploration.
```{r}
full %>% 
 dplyr::select(-contains("weight")) %>% 
 mutate(across(2:7, as.factor)) %>% 
 mutate(race_ethnicity = as.factor(paste0(race, ", ", ethnicity)),
        strata_label = paste(region, race_ethnicity, sexuality, sex, age, sep = "_")) %>% 
 filter(wave == 4) %>% 
 dplyr::select(1:8, strata_label) %>% #33,822
 drop_na() %>% #33,389
 group_by(strata_label) %>% 
 summarise(tot = sum(eprod_edsd))
```

We have 278 strata if we keep all of these. Not use sexual orientation b/c not imputed. Omit that from analysis. I'll take out this variable and modify the race/ethnicity coding.

### Data prep

```{r}
dat <- full %>% 
 dplyr::select(-contains("weight")) %>% 
 mutate(across(region:age, as.factor)) %>% 
 mutate(race_ethnicity = as.factor(case_when(race == "Black" & ethnicity == "Not Hispanic" ~ "Black",
                                   race == "White" & ethnicity == "Not Hispanic" ~ "White",
                                   ethnicity == "Hispanic" ~ "Hispanic",
                                   TRUE ~ "Other"))) %>% 
 dplyr::select(id, #ID
        wave, #wave
        region, race_ethnicity, sex, age, #strata
        eprod_edsd #outcome
        ) 
#64,623 observations
```

```{r}
dat <- dat %>% 
 drop_na() #64,539

#84 observations with any missing values

dat <- dat %>% 
 mutate(strata_label = as.factor(paste(region, race_ethnicity, sex, age, sep = "_")))
```


Let's see how many individuals we have in each strata (and if any are empty).
```{r}
dat %>% 
 group_by(strata_label) %>% 
 summarize(tot = sum(eprod_edsd)) %>% 
 arrange(tot)
```

We might consider doing some combining. At the very least, let's combine "Northeast_Other_Male_45+" and "West_Other_Male_45+" so the minimum n of any given strata is 5.

```{r}
dat <- dat %>% 
 mutate(strata_label = case_when(
    strata_label %in% c("Northeast_Other_Male_45+", "West_Other_Male_45+") ~ "NortheastWest_Other_Male_45+",
    TRUE ~ strata_label
  ))
```

Check if it worked.
```{r}
dat %>% 
 group_by(strata_label) %>% 
 summarize(tot = sum(eprod_edsd)) %>% 
 arrange(tot)
```

Question: this works for the strata, but how do we do that for the additive model?

### Running the models

From Evans et al. (2024): linear models are fit using restricted maximum likelihood estimation (RMLE) using the function lmer, and logistic models are fitted using a Laplace Approximation of maximum likelihood estimation using the funtion glmer.

Our outcome is everyday/someday E-product usage (`eprod_edsd`).

#### Null model

```{r}
library(lme4)

mod1 <- glmer(eprod_edsd ~ (1 | strata_label), 
               data = dat,
               family = binomial(link = "logit"))

summary(mod1)

# Predict the fitted linear predictor (on the probability scale)
dat$mod1xbu <- predict(mod1, type = "response")

# Predict the linear predictor for the fixed portion of the model only
# (only the intercept, so this is just the weighted grand mean probability)
dat$mod1xb <- predict(mod1, type="response", re.form=NA)
```

#### Additive model

```{r}
library(merTools)

mod2 <- glmer(eprod_edsd ~ region + race_ethnicity + sex + age + (1 | strata_label),
                data = dat,
                family = binomial(link = "logit"))

summary(mod2)

# Predict the fitted linear predictor (on the probability scale)
dat$mod2m <- predict(mod2, type = "response")


# predict the fitted linear predictor, and confidence intervals, on the logit 
# scale
m2m <- predictInterval(mod2, level=0.95, include.resid.var=FALSE)
# create a new id variable for this newly created dataframe
m2m <- mutate(m2m, id=row_number())

# on the logit scale, predict the linear predictor for the fixed portion of the
# model only
dat$m2mF <- predict(mod2, re.form=NA)

# predict the fitted linear predictor, and confidence intervals, on the 
# probability scale
m2m_prob <- predictInterval(mod2, level=0.95, include.resid.var=FALSE, 
                             type="probability") 
# note that, unlike the stata code, this code combines the uncertainty from the
# fixed and random parts. This saves a step later compared to the Stata code.

# create a new id variable for this newly created dataframe
m2m_prob <- mutate(m2m_prob, id=row_number())

# predict the fitted linear predictor, on the probability scale, for the fixed 
# portion of the model only
dat$m2xb <- predict(mod2, re.form=NA, type="response")

#predict the stratum random effects and associated standard errors
m2u <- REsim(mod2)

```

```{r}
vc1a <-as.data.frame(VarCorr(mod1))
vc1b <-as.data.frame(VarCorr(mod2))

PCV1 <- ((vc1a[1,4] - vc1b[1,4]) / vc1a[1,4])*100
PCV1 #89.28
```

### Visualizations

#### Histograms

```{r}
# Histogram of the observed stratum means (and mean of means)
dat %>% 
 group_by(strata_label) %>% 
 summarise(avg = mean(eprod_edsd)) %>% 
 ggplot(., aes(avg)) +
 geom_histogram(fill = "gray") +
  labs(title = "Observed Eproduct Use",
       x = "Observed Eprod Use",
       y = "Percent of Strata") +
 geom_vline(aes(xintercept = mean(avg))) +
 theme_minimal()


# Histogram of the predicted stratum means
ggplot(dat, aes(x=mod1xbu)) + 
  geom_histogram(aes(y = after_stat(count / sum(count))), fill = "gray") + 
  scale_y_continuous(labels=scales::percent) +
  labs(title = "Predicted Eproduct Use",
       x = "Predicted Eprod Use",
       y = "Percent of Strata") +
  geom_vline(aes(xintercept=0.0923))+ #this is the precision weighted grand mean
  theme_minimal()
```

#### Ranks

Okay, stopping here.




Notes for later:
- Elaborate, why not chisq or single-level?
- Create colorful caterpillar plots

