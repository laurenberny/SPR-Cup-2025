---
title: "Exploratorium"
author: "Anwesha Guha"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
pacman::p_load(here, rio, tidyverse)
```

```{r}
load(here("data", "combined_clean.RData"))
```

## Weight exploration

The weighted tutorial notes to calibrate weights to standardize mean? I am just curious about what these weights look like, so let's see weight 2. Strange that there are so many NAs.
```{r}
summary(full$rep_weight_2) #1,199
length(unique(full$id)) #63,181 weights -- #43,932 IDs
```

Note for weights (from video):
- `survey` package in R can handle weights
- use BRR variance estimation (another option is linearization/Taylor Series)
- cross-sectional weights are specific to wave; single-wave is slightly different. We have the cross-sectional weights since we are looking at overall characteristics of the Wave 4 vs Wave 7 samples. If we were interested in individual-level tracking, we'd use the all-waves weights, but that's not relevant to our RQs.

## Omitting weights

### Data exploration

Create variable factors and strata.
```{r}
full %>% 
 dplyr::select(-contains("weight")) %>% 
 mutate(across(2:7, as.factor)) %>% 
 mutate(race_ethnicity = as.factor(paste0(race, ", ", ethnicity)),
        strata_label = paste(region, race_ethnicity, sexuality, sex, age, sep = "_")) %>% 
 head()
```

Descriptive summary by strata
```{r}
full %>% 
  dplyr::select(-contains("weight")) %>% 
 mutate(across(2:7, as.factor)) %>% 
 mutate(race_ethnicity = as.factor(paste0(race, ", ", ethnicity)),
        strata_label = paste(region, race_ethnicity, sexuality, sex, age, sep = "_")) %>% 
 group_by(strata_label) %>% 
 summarise(tot = sum(eprod_edsd)) %>% 
 arrange(tot)
```

Remove NA values? What is the best method we want to use?

I'm doing listwise just to continue on with the exploration.
```{r}
full %>% 
 dplyr::select(-contains("weight")) %>% 
 mutate(across(2:7, as.factor)) %>% 
 mutate(race_ethnicity = as.factor(paste0(race, ", ", ethnicity)),
        strata_label = paste(region, race_ethnicity, sexuality, sex, age, sep = "_")) %>% 
 filter(wave == 4) %>% 
 dplyr::select(1:8, strata_label) %>% #33,822
 drop_na() %>% #33,389
 group_by(strata_label) %>% 
 summarise(tot = sum(eprod_edsd))
```

We have 278 strata if we keep all of these. Not use sexual orientation b/c not imputed. Omit that from analysis. I'll take out this variable and modify the race/ethnicity coding.

### Data prep

```{r}
dat <- full %>% 
 dplyr::select(-contains("weight")) %>% 
 mutate(across(region:age, as.factor)) %>% 
 mutate(race_ethnicity = as.factor(case_when(race == "Black" & ethnicity == "Not Hispanic" ~ "Black",
                                   race == "White" & ethnicity == "Not Hispanic" ~ "White",
                                   ethnicity == "Hispanic" ~ "Hispanic",
                                   TRUE ~ "Other"))) %>% 
 dplyr::select(id, #ID
        wave, #wave
        region, race_ethnicity, sex, age, #strata
        eprod_edsd #outcome
        ) 
#64,623 observations
```

```{r}
dat <- dat %>% 
 drop_na() #64,539

#84 observations with any missing values

dat <- dat %>% 
 mutate(strata_label = as.factor(paste(region, race_ethnicity, sex, age, sep = "_")))
```


Let's see how many individuals we have in each strata (and if any are empty).


```{r}
dat %>% 
 group_by(strata_label) %>% 
 summarize(tot = sum(eprod_edsd)) %>% 
 arrange(tot)
```

We might consider doing some combining. At the very least, let's combine "Northeast_Other_Male_45+" and "West_Other_Male_45+" so the minimum n of any given strata is 5.

```{r}
dat <- dat %>% 
 mutate(strata_label2 = case_when(
    strata_label %in% c("Northeast_Other_Male_45+", "West_Other_Male_45+") ~ "NortheastWest_Other_Male_45+",
    TRUE ~ strata_label
  ))
```

Check if it worked.
```{r}
dat %>% 
 group_by(strata_label) %>% 
 summarize(tot = sum(eprod_edsd)) %>% 
 arrange(tot)
```

Question: this works for the strata, but how do we do that for the additive model?

### Running the models

From Evans et al. (2024): linear models are fit using restricted maximum likelihood estimation (RMLE) using the function lmer, and logistic models are fitted using a Laplace Approximation of maximum likelihood estimation using the funtion glmer.

Our outcome is everyday/someday E-product usage (`eprod_edsd`).

#### Null model

```{r}
dat_4 <- dat %>% 
 filter(wave == 4)

dat_7 <- dat %>% 
 filter(wave == 7)
```

```{r}
dat_4 %>% 
 group_by(strata_label) %>% 
 summarize(tot = sum(eprod_edsd)) %>% 
 arrange(tot)
```

```{r}
dat_7 %>% 
 group_by(strata_label) %>% 
 summarize(tot = sum(eprod_edsd)) %>% 
 arrange(tot)
```


```{r}
library(lme4)

mod1_4 <- glmer(eprod_edsd ~ (1 | strata_label), 
               data = dat_4,
               family = binomial(link = "logit"))

summary(mod1_4)

# Predict the fitted linear predictor (on the probability scale)
dat_4$mod1xbu <- predict(mod1_4, type = "response")

# Predict the linear predictor for the fixed portion of the model only
# (only the intercept, so this is just the weighted grand mean probability)
dat_4$mod1xb <- predict(mod1_4, type="response", re.form=NA)
```

```{r}
library(lme4)

mod1_7 <- glmer(eprod_edsd ~ (1 | strata_label), 
               data = dat_7,
               family = binomial(link = "logit"))

summary(mod1_7)

# Predict the fitted linear predictor (on the probability scale)
dat_7$mod1xbu <- predict(mod1_7, type = "response")

# Predict the linear predictor for the fixed portion of the model only
# (only the intercept, so this is just the weighted grand mean probability)
dat_7$mod1xb <- predict(mod1_7, type="response", re.form=NA)
```

#### Additive model

```{r}
library(merTools)

mod2_4 <- glmer(eprod_edsd ~ region + race_ethnicity + sex + age + (1 | strata_label),
                data = dat_4,
                family = binomial(link = "logit")) #change reference to White, Male, 18-24, Northeast or West

summary(mod2_4)

# Predict the fitted linear predictor (on the probability scale)
dat_4$mod2m <- predict(mod2_4, type = "response")


# predict the fitted linear predictor, and confidence intervals, on the logit 
# scale
m2m_4 <- predictInterval(mod2_4, level=0.95, include.resid.var=FALSE)
# create a new id variable for this newly created dataframe
m2m_4 <- mutate(m2m_4, id=row_number())

# on the logit scale, predict the linear predictor for the fixed portion of the
# model only
dat_4$m2mF <- predict(mod2_4, re.form=NA)

# predict the fitted linear predictor, and confidence intervals, on the 
# probability scale
m2m_prob_4 <- predictInterval(mod2_4, level=0.95, include.resid.var=FALSE, 
                             type="probability") 
# note that, unlike the stata code, this code combines the uncertainty from the
# fixed and random parts. This saves a step later compared to the Stata code.

# create a new id variable for this newly created dataframe
m2m_prob_4 <- mutate(m2m_prob_4, id=row_number())

# predict the fitted linear predictor, on the probability scale, for the fixed 
# portion of the model only
dat_4$m2xb <- predict(mod2_4, re.form=NA, type="response")

#predict the stratum random effects and associated standard errors
m2u_4 <- REsim(mod2_4)

```

```{r}
library(merTools)

mod2_7 <- glmer(eprod_edsd ~ region + race_ethnicity + sex + age + (1 | strata_label),
                data = dat_7,
                family = binomial(link = "logit"))

summary(mod2_7)

# Predict the fitted linear predictor (on the probability scale)
dat_7$mod2m <- predict(mod2_7, type = "response")


# predict the fitted linear predictor, and confidence intervals, on the logit 
# scale
m2m_7 <- predictInterval(mod2_7, level=0.95, include.resid.var=FALSE)
# create a new id variable for this newly created dataframe
m2m_7 <- mutate(m2m_7, id=row_number())

# on the logit scale, predict the linear predictor for the fixed portion of the
# model only
dat_7$m2mF <- predict(mod2_7, re.form=NA)

# predict the fitted linear predictor, and confidence intervals, on the 
# probability scale
m2m_prob_7 <- predictInterval(mod2_7, level=0.95, include.resid.var=FALSE, 
                             type="probability") 
# note that, unlike the stata code, this code combines the uncertainty from the
# fixed and random parts. This saves a step later compared to the Stata code.

# create a new id variable for this newly created dataframe
m2m_prob_7 <- mutate(m2m_prob_7, id=row_number())

# predict the fitted linear predictor, on the probability scale, for the fixed 
# portion of the model only
dat_7$m2xb <- predict(mod2_7, re.form=NA, type="response")

#predict the stratum random effects and associated standard errors
m2u_7 <- REsim(mod2_7)

```

```{r}
vc1a <-as.data.frame(VarCorr(mod1_7))
vc1b <-as.data.frame(VarCorr(mod2_7))

PCV1 <- ((vc1a[1,4] - vc1b[1,4]) / vc1a[1,4])*100
PCV1 #89.28

# Models for Wave 4 = 79.74
# Models for Wave 7 = 92.37
```

```{r}

library(Metrics)
## Wave 7

# Calculate the area under the receiver operating characteristic (ROC) curve
# for model 2a - based on intercept and stratum random effects
AUC2A <- auc(dat_7$eprod_edsd, dat_7$mod1xbu)

#for model 2A - based on only the fixed portion of the model
AUC2AF <- auc(dat_7$eprod_edsd, dat_7$mod1xb)

#for model 2b - based on intercept, main effects, and stratum random effects
AUC2B <- auc(dat_7$eprod_edsd, dat_7$m2mF)
#for model 2b - based on the fixed portion of the model (main effects)
AUC2BF <- auc(dat_7$eprod_edsd, dat_7$m2xb) 

#output the AUC calculations
AUC2A
AUC2AF
AUC2B
AUC2BF
```

```{r}
## Wave 4

# Calculate the area under the receiver operating characteristic (ROC) curve
# for model 2a - based on intercept and stratum random effects
AUC2A <- auc(dat_4$eprod_edsd, dat_4$mod1xbu)

#for model 2A - based on only the fixed portion of the model
AUC2AF <- auc(dat_4$eprod_edsd, dat_4$mod1xb)

#for model 2b - based on intercept, main effects, and stratum random effects
AUC2B <- auc(dat_4$eprod_edsd, dat_4$m2mF)
#for model 2b - based on the fixed portion of the model (main effects)
AUC2BF <- auc(dat_4$eprod_edsd, dat_4$m2xb) 

#output the AUC calculations
AUC2A
AUC2AF
AUC2B
AUC2BF
```


### Visualizations

#### Histograms

```{r}
# Histogram of the observed stratum means (and mean of means)
dat_4 %>% 
 group_by(strata_label) %>% 
 summarise(avg = mean(eprod_edsd)) %>% 
 ggplot(., aes(avg)) +
 geom_histogram(fill = "gray") +
  labs(title = "Observed Eproduct Use",
       x = "Observed Eprod Use",
       y = "Percent of Strata") +
 geom_vline(aes(xintercept = mean(avg))) +
 theme_minimal()


# Histogram of the predicted stratum means
ggplot(dat_4, aes(x=mod1xbu)) + 
  geom_histogram(aes(y = after_stat(count / sum(count))), fill = "gray") + 
  scale_y_continuous(labels=scales::percent) +
  labs(title = "Predicted Eproduct Use",
       x = "Predicted Eprod Use",
       y = "Percent of Strata") +
  geom_vline(aes(xintercept=0.07583355))+ #this is the precision weighted grand mean
  theme_minimal()
```


```{r}
# Histogram of the observed stratum means (and mean of means)
dat_7 %>% 
 group_by(strata_label) %>% 
 summarise(avg = mean(eprod_edsd)) %>% 
 ggplot(., aes(avg)) +
 geom_histogram(fill = "gray") +
  labs(title = "Observed Eproduct Use",
       x = "Observed Eprod Use",
       y = "Percent of Strata") +
 geom_vline(aes(xintercept = mean(avg))) +
 theme_minimal()


# Histogram of the predicted stratum means
ggplot(dat_7, aes(x=mod1xbu)) + 
  geom_histogram(aes(y = after_stat(count / sum(count))), fill = "gray") + 
  scale_y_continuous(labels=scales::percent) +
  labs(title = "Predicted Eproduct Use",
       x = "Predicted Eprod Use",
       y = "Percent of Strata") +
  geom_vline(aes(xintercept=0.1078718))+ #this is the precision weighted grand mean
  theme_minimal()
```

#### Ranks

Okay, stopping here.




Notes for later:
- Elaborate, why not chisq or single-level?
- Create colorful caterpillar plots

